#+TITLE: Identity spell that canceled due to earning
#+SUBTITLE: Using SQL for doing Data Analysis
#+AUTHOR: Ruisha
#+EMAIL: ruishaz@gmail.com
#+STARTUP: showeverything
#+STARTUP: nohideblocks

* Before we start

- Self-suffiency measurement that human service department is current using is called case canceled due to earning
- Data tables including snap case canceled due to earning, tanf case canceled due to earning, head of household spells.  
- Goal: generate intermediate tables for next step.

* The data set

snap/tanf canceled due to earning is organized by chapen hall id (primary key).
There are different types of dates for case cancel process. We choose transaction_date as the benchmark.

head of household spell table is organized by recipent id (primary key).
There are spell type, spell starting & ending date, and some demographic about the spell receipent.  

** Case canceled due to earning measure 

- This measure evaluates how well spell recipents are doing at the time of cancelation. 
- For example: If 5% of all cases that were canceled due to earning last quarter, 6% are canceled due to earning this quarter, self-sufficiency of spell recipent is increasing as the department believes.  

** Data tables: snap case canceled due to earning, tanf case canceled due to earning

- Case canceled due to earning are tagged in a table with chapen hall id and a date. 

** Data tables: head of household spells 
- Head of household spell information include caseid (primary key), chapen hall id, and spell start and end date.

** Intermidiate data set
- Goal: link case canceled due to earning with head of household table to tag the spell with a 0/1 case canceled due to earning column.

Link snap canceled with head of household spell using the functions  =partition by= 

#+BEGIN_SRC sql
//tag the specific spell that canceled due to earning for foodstamp
SQL:
DROP TABLE IF EXISTS c6.snap_cancelled_identify_hh_indcase_spells ;
CREATE TABLE c6.snap_cancelled_identify_hh_indcase_spells AS 
SELECT *, 1 as tag_cancel
FROM(
	SELECT cancel.ch_dpa_caseid, cancel.transaction_date,
	spell.recptno, spell.benefit_type, spell.end_date , 
	(cancel.transaction_date-spell.end_date) as days_between_end_cancel,
	FIRST_VALUE(spell.end_date) 
		OVER (PARTITION BY cancel.transaction_date 
		ORDER BY ABS(cancel.transaction_date-spell.end_date))
	FROM idhs.snap_cancelled_earnings_redacted cancel
	LEFT JOIN idhs.hh_indcase_spells spell
	ON cancel.ch_dpa_caseid=spell.ch_dpa_caseid
	WHERE (cancel.ch_dpa_caseid IS NOT NULL) AND 
	(spell.benefit_type LIKE '%foodstamp%')
) temp
WHERE ABS(days_between_end_cancel)<=60
ORDER BY ABS(days_between_end_cancel)
#+END_SRC

Link tanf canceled with head of household spell, same logic 

#+BEGIN_SRC sql
//tag the specific spell that canceled due to earning for tanf
DROP TABLE IF EXISTS c6.tanf_cancelled_identify_hh_indcase_spells ;
CREATE TABLE c6.tanf_cancelled_identify_hh_indcase_spells AS 
SELECT *, 1 as tag_cancel_tanf
FROM(
	SELECT cancel.ch_dpa_caseid, cancel.transaction_date,
	spell.recptno, spell.benefit_type, spell.end_date , 
	(cancel.transaction_date-spell.end_date) as days_between_end_cancel,
	FIRST_VALUE(spell.end_date) 
		OVER (PARTITION BY cancel.transaction_date 
		ORDER BY ABS(cancel.transaction_date-spell.end_date))
	FROM idhs.tanf_cancelled_earnings_redacted cancel
	LEFT JOIN idhs.hh_indcase_spells spell
	ON cancel.ch_dpa_caseid=spell.ch_dpa_caseid
	WHERE (cancel.ch_dpa_caseid IS NOT NULL) AND 
	(spell.benefit_type LIKE '%tanf%')
	order by cancel.ch_dpa_caseid,spell.end_date
) temp
WHERE ABS(days_between_end_cancel)<=60
ORDER BY ABS(days_between_end_cancel)
#+END_SRC

*** Idea behind:

use all cases in idhs.snap_cancelled_earnings_redacted (where ch_dpa_caseid is not missing )
go merge with idhs.hh_indcase_spells spell to identify the specicfic spell that is canceled due to earning. 
tag the record of the smallest gap days btw transaction_date & spell.end_date 
if the gap is more than 60 days, I make the judgement that the spell is not related to the transaction_date.

* Find the earlist return spell of an ending spell 

* The data set

The data set is head of household spells (idhs.hh_indcase_spells). 
Head of household spell table is organized by recipent id (primary key).
There are spell type, spell starting & ending date, and some demographic about the spell receipent.  

** Intermidiate data set
- Goal: Find out whether there is a return spell or not given each ending spell for validation part of the project

We would be using the functions  =group by= AND  =order by= to find the earlist return spell

#+BEGIN_SRC sql

DROP TABLE IF EXISTS c6.return_hh_indcase_spells ;
CREATE TABLE c6.return_hh_indcase_spells AS
SELECT sub.recptno,sub.oldSpell_end,sub.oldBene_type,
min(sub.ch_dpa_caseid) AS ch_dpa_caseid,avg(sub.member_age) AS member_age, min(sub.newSpell_start) as next_spell_start_date, min(sub.returnSpell_gap) as gap,
CASE
 WHEN min(sub.returnSpell_gap) <1000000 THEN 1
 ELSE 0
 END AS "return_index",
CASE When count(*)=1 AND min(sub.returnSpell_gap)=1000000 THEN 0
ELSE count(*)
END AS "total_future_spell"
FROM
	(SELECT a.recptno, a.ch_dpa_caseid,a.benefit_type AS oldBene_type,
	a.end_date AS oldSpell_end, 
	AGE(a.end_date, a.birth_date )AS member_age,
	b.benefit_type AS newBene_type,
	b.start_date AS newSpell_start,
	CASE
		WHEN b.start_date IS NULL THEN 1000000
		ELSE ( b.start_date- a.end_date ) 
		END AS returnSpell_gap
	FROM c6.hh_indcase_spells_nogrant a
	LEFT JOIN c6.hh_indcase_spells_nogrant b
	ON (a.recptno=b.recptno) AND (a.end_date<b.start_date)
 	order by 1,3,4,6,7
	)sub
group by 1,2,3
order by 1,2,3;
#+END_SRC

*** Idea behind:

the inner select from : use all spells in idhs.hh_indcase_spells spell that exclude grant(c6.hh_indcase_spells_nogrant) 
and left join with itself to construct one ending spell with all possible future return spell
then calculate the gap between the ending spell and all future return spells (returnSpell_gap)
and rank the gap from the shortest the longest, if there is no future return spell, give a 1m value 
the outter select from : keep one ending spell a record with a  0/1 return_index, smallest gap days, and total number of future return spells.  


* Some basic tasks in a data analysis project

- Cleaning the data
- Manipulating the data
- Create new /FeatureS/
- Create new views of the data
- Answering analytical questions
